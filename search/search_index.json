{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Documentation Page for IO-Tracer! Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology. What is IO-Tracer? IO-Tracer is a research tool that collects information about how computers use their storage systems. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices. Background Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls. What do we collect? IO-Tracer collects five key types of hardware information to provide comprehensive insights into computational operations. First, it captures the precise timestamp of each operation to establish when activities occur. Second, it records the type of operation being performed, whether it's opening, reading, writing, or closing files. Third, it identifies which specific process ( process name ) is performing each operation. Finally, it logs the file location information, including both the file path and technical identifiers that specify where operations are taking place. Finally, it measures the size of data being requested during each operation. How do we use the collected information? The information collected by IO-Tracer serves as valuable input for academic research. Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent. We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"Introduction"},{"location":"#welcome-to-documentation-page-for-io-tracer","text":"Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology.","title":"Welcome to Documentation Page for IO-Tracer!"},{"location":"#what-is-io-tracer","text":"IO-Tracer is a research tool that collects information about how computers use their storage systems. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices.","title":"What is IO-Tracer?"},{"location":"#background","text":"Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls.","title":"Background"},{"location":"#what-do-we-collect","text":"IO-Tracer collects five key types of hardware information to provide comprehensive insights into computational operations. First, it captures the precise timestamp of each operation to establish when activities occur. Second, it records the type of operation being performed, whether it's opening, reading, writing, or closing files. Third, it identifies which specific process ( process name ) is performing each operation. Finally, it logs the file location information, including both the file path and technical identifiers that specify where operations are taking place. Finally, it measures the size of data being requested during each operation.","title":"What do we collect?"},{"location":"#how-do-we-use-the-collected-information","text":"The information collected by IO-Tracer serves as valuable input for academic research. Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent. We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"How do we use the collected information?"},{"location":"privacy/","text":"Privacy Protection Measures Automatic Filtering The tool systematically excludes virtual filesystems such as /proc , /sys , /dev , and tmpfs , which contain system-generated information rather than hardware information. To prevent recursive loops and maintain system performance, the tracer implements self-tracing prevention by automatically excluding its own input/output operations from the collection. Additionally, the system filters out special files including pipes, sockets, and device files. Data Minimization Techniques The tool features configurable cache event sampling, allowing researchers to capture representative information patterns by recording only a specified ratio of events, such as one in every ten operations. To prevent excessive storage consumption, the tool implements time-based log rotation with a default 24-hour cycle, automatically archiving older data while maintaining recent activity logs. Process-specific filtering capabilities enable users to focus data collection on particular applications or exclude unnecessary system processes from monitoring. Finally, the tool incorporates automatic compression and cleanup routines that optimize storage space and remove outdated information. Excluded Information File contents or personal user data Network packet payloads User credentials or passwords Environment variables Command-line arguments beyond process names","title":"Data Collection"},{"location":"privacy/#privacy-protection-measures","text":"","title":"Privacy Protection Measures"},{"location":"privacy/#automatic-filtering","text":"The tool systematically excludes virtual filesystems such as /proc , /sys , /dev , and tmpfs , which contain system-generated information rather than hardware information. To prevent recursive loops and maintain system performance, the tracer implements self-tracing prevention by automatically excluding its own input/output operations from the collection. Additionally, the system filters out special files including pipes, sockets, and device files.","title":"Automatic Filtering"},{"location":"privacy/#data-minimization-techniques","text":"The tool features configurable cache event sampling, allowing researchers to capture representative information patterns by recording only a specified ratio of events, such as one in every ten operations. To prevent excessive storage consumption, the tool implements time-based log rotation with a default 24-hour cycle, automatically archiving older data while maintaining recent activity logs. Process-specific filtering capabilities enable users to focus data collection on particular applications or exclude unnecessary system processes from monitoring. Finally, the tool incorporates automatic compression and cleanup routines that optimize storage space and remove outdated information.","title":"Data Minimization Techniques"},{"location":"privacy/#excluded-information","text":"File contents or personal user data Network packet payloads User credentials or passwords Environment variables Command-line arguments beyond process names","title":"Excluded Information"},{"location":"startlinux/","text":"Quick Start Guide | Linux Prerequisites Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC You can execute these commands for BCC installation: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide Basic Usages Infinite tracing (Exit on demand) sudo python3 iotrc.py Quick Start (30 Seconds Trace) sudo python3 iotrc.py -d 30 Command Options Core options -d, --duration <seconds> - Duration to trace (default: indefinite) -o, --output <directory> - Output directory (default: auto-generated) -v, --verbose - Enable verbose logging -a, --anonimize - Anonymize process and file names Advance options -b BPF_FILE, --bpf-file BPF_FILE - BPF C source file path -p PAGE_CNT, --page-cnt PAGE_CNT - Number of pages for perf buffer (default 8) -s SPLIT_THRESHOLD, --split_threshold SPLIT_THRESHOLD - Split threshold in seconds (default 1 day) -a, --anonimize - Enable anonymization of process and file names -uc, --uncompressed - Enable uncompressed output","title":"Quick Start Linux"},{"location":"startlinux/#quick-start-guide-linux","text":"","title":"Quick Start Guide | Linux"},{"location":"startlinux/#prerequisites","text":"Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC You can execute these commands for BCC installation: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide","title":"Prerequisites"},{"location":"startlinux/#basic-usages","text":"Infinite tracing (Exit on demand) sudo python3 iotrc.py Quick Start (30 Seconds Trace) sudo python3 iotrc.py -d 30","title":"Basic Usages"},{"location":"startlinux/#command-options","text":"","title":"Command Options"},{"location":"startlinux/#core-options","text":"-d, --duration <seconds> - Duration to trace (default: indefinite) -o, --output <directory> - Output directory (default: auto-generated) -v, --verbose - Enable verbose logging -a, --anonimize - Anonymize process and file names","title":"Core options"},{"location":"startlinux/#advance-options","text":"-b BPF_FILE, --bpf-file BPF_FILE - BPF C source file path -p PAGE_CNT, --page-cnt PAGE_CNT - Number of pages for perf buffer (default 8) -s SPLIT_THRESHOLD, --split_threshold SPLIT_THRESHOLD - Split threshold in seconds (default 1 day) -a, --anonimize - Enable anonymization of process and file names -uc, --uncompressed - Enable uncompressed output","title":"Advance options"},{"location":"startwin/","text":"Quick Start Guide | Windows \ud83c\udfa5 Here\u2019s a quick video guide on installation and usage: Quick Start | IO Tracer for Windows Installation Download the .zip file from the GitHub Release page and extract it. Move the extracted folder to your preferred location. We recommend placing it under the Documents folder for easy access. \u2705 Installation complete! Basic Usage Run the program as administrator Right\u2013click the file with the binocular icon and choose Run as administrator . Program starts running Once started, you\u2019ll see the tool actively tracing. Check the output After closing the program, results will be saved inside the output folder. \u26a0\ufe0f Important: To stop the program, do not close the terminal window directly. Instead, press Ctrl + C to safely terminate it.","title":"Quick Start Windows"},{"location":"startwin/#quick-start-guide-windows","text":"\ud83c\udfa5 Here\u2019s a quick video guide on installation and usage: Quick Start | IO Tracer for Windows","title":"Quick Start Guide | Windows"},{"location":"startwin/#installation","text":"Download the .zip file from the GitHub Release page and extract it. Move the extracted folder to your preferred location. We recommend placing it under the Documents folder for easy access. \u2705 Installation complete!","title":"Installation"},{"location":"startwin/#basic-usage","text":"Run the program as administrator Right\u2013click the file with the binocular icon and choose Run as administrator . Program starts running Once started, you\u2019ll see the tool actively tracing. Check the output After closing the program, results will be saved inside the output folder. \u26a0\ufe0f Important: To stop the program, do not close the terminal window directly. Instead, press Ctrl + C to safely terminate it.","title":"Basic Usage"},{"location":"technicalnux/","text":"Technical Details - Linux Data Collection Methodology Implementation Using eBPF-based kernel probes (kprobes) Kernel Probe Points Layer Functions Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer blk_mq_start_request Page Cache filemap_add_folio (miss), folio_mark_accessed (hit) Output Directory Structures result/IO_trace_analysis_YYYYMMDD_HHMMSS/ \u251c\u2500 raw_trace_YYYYMMDD_HHMMSS.tar.gz \u251c\u2500\u2500 vfs/log/vfs_trace_*.log \u251c\u2500\u2500 block/log/block_trace_*.log \u2514\u2500\u2500 cache/log/cache_trace_*.log Filesystem Trace Format Log Format timestamp op_name pid comm filename inode size_val flags_str Field Specs Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive op_name string Operation (READ/WRITE/OPEN/CLOSE/FSYNC) Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) filename char[256] File name Non-sensitive (Does not contain personal info) inode uint64 File inode number Non-sensitive size_val uint64 I/O size in bytes Non-sensitive flags_str string Open flags (e.g., O_RDONLY) Non-sensitive Example: 1234567890 READ 1234 firefox config.txt 98765 4096 O_RDONLY|O_DIRECT Block I/O Trace Format Log Format timestamp pid tid comm sector nr_sectors operation cpu_id parent_info bio_size Field Spec Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive tid uint32 Thread identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) sector uint64 Disk sector (LBA) Non-sensitive nr_sectors uint32 Number of sectors Non-sensitive operation string Operation type (REQ_OP_READ/WRITE) Non-sensitive cpu_id uint32 CPU core identifier Non-sensitive parent_info string Parent process information Non-sensitive (Does not contain personal info) bio_size uint64 Block I/O size in bytes Non-sensitive Example: 1234567890 1234 5678 mysqld 2048576 256 REQ_OP_WRITE cpu:0 ppid:1(systemd) 131072 Page Cache Trace Data Format Log Format timestamp pid comm status Field Spec Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive status string HIT or MISS Non-sensitive Example: 1234567890 1234 chrome HIT","title":"Technical Details Linux"},{"location":"technicalnux/#technical-details-linux","text":"","title":"Technical Details - Linux"},{"location":"technicalnux/#data-collection-methodology","text":"","title":"Data Collection Methodology"},{"location":"technicalnux/#implementation","text":"Using eBPF-based kernel probes (kprobes)","title":"Implementation"},{"location":"technicalnux/#kernel-probe-points","text":"Layer Functions Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer blk_mq_start_request Page Cache filemap_add_folio (miss), folio_mark_accessed (hit)","title":"Kernel Probe Points"},{"location":"technicalnux/#output-directory-structures","text":"result/IO_trace_analysis_YYYYMMDD_HHMMSS/ \u251c\u2500 raw_trace_YYYYMMDD_HHMMSS.tar.gz \u251c\u2500\u2500 vfs/log/vfs_trace_*.log \u251c\u2500\u2500 block/log/block_trace_*.log \u2514\u2500\u2500 cache/log/cache_trace_*.log","title":"Output Directory Structures"},{"location":"technicalnux/#filesystem-trace-format","text":"","title":"Filesystem Trace Format"},{"location":"technicalnux/#log-format","text":"timestamp op_name pid comm filename inode size_val flags_str","title":"Log Format"},{"location":"technicalnux/#field-specs","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive op_name string Operation (READ/WRITE/OPEN/CLOSE/FSYNC) Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) filename char[256] File name Non-sensitive (Does not contain personal info) inode uint64 File inode number Non-sensitive size_val uint64 I/O size in bytes Non-sensitive flags_str string Open flags (e.g., O_RDONLY) Non-sensitive Example: 1234567890 READ 1234 firefox config.txt 98765 4096 O_RDONLY|O_DIRECT","title":"Field Specs"},{"location":"technicalnux/#block-io-trace-format","text":"","title":"Block I/O Trace Format"},{"location":"technicalnux/#log-format_1","text":"timestamp pid tid comm sector nr_sectors operation cpu_id parent_info bio_size","title":"Log Format"},{"location":"technicalnux/#field-spec","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive tid uint32 Thread identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) sector uint64 Disk sector (LBA) Non-sensitive nr_sectors uint32 Number of sectors Non-sensitive operation string Operation type (REQ_OP_READ/WRITE) Non-sensitive cpu_id uint32 CPU core identifier Non-sensitive parent_info string Parent process information Non-sensitive (Does not contain personal info) bio_size uint64 Block I/O size in bytes Non-sensitive Example: 1234567890 1234 5678 mysqld 2048576 256 REQ_OP_WRITE cpu:0 ppid:1(systemd) 131072","title":"Field Spec"},{"location":"technicalnux/#page-cache-trace-data-format","text":"","title":"Page Cache Trace Data Format"},{"location":"technicalnux/#log-format_2","text":"timestamp pid comm status","title":"Log Format"},{"location":"technicalnux/#field-spec_1","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive status string HIT or MISS Non-sensitive Example: 1234567890 1234 chrome HIT","title":"Field Spec"},{"location":"technicalwin/","text":"Technical Details - Windows Event Tracing for Windows (ETW) Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time Implementation Details Session Management The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators. Event Processing Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite. Event Types Captured File system operations include Read , Write , Create , Delete , Close , and Flush operations. Raw disk I/O operations are captured to monitor low-level disk read/write operations. Memory-related events such as page faults and virtual memory allocation are available but currently disabled in the implementation.","title":"Technical Details Windows"},{"location":"technicalwin/#technical-details-windows","text":"","title":"Technical Details - Windows"},{"location":"technicalwin/#event-tracing-for-windows-etw","text":"Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time","title":"Event Tracing for Windows (ETW)"},{"location":"technicalwin/#implementation-details","text":"","title":"Implementation Details"},{"location":"technicalwin/#session-management","text":"The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators.","title":"Session Management"},{"location":"technicalwin/#event-processing","text":"Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite.","title":"Event Processing"},{"location":"technicalwin/#event-types-captured","text":"File system operations include Read , Write , Create , Delete , Close , and Flush operations. Raw disk I/O operations are captured to monitor low-level disk read/write operations. Memory-related events such as page faults and virtual memory allocation are available but currently disabled in the implementation.","title":"Event Types Captured"}]}