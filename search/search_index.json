{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Documentation Page for IO-Tracer! Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology. Source code: https://github.com/cacheMon/io-tracer-win https://github.com/cacheMon/io-tracer What is IO-Tracer? IO-Tracer is a research tool that collects information about how hardware is utilized. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices. Background Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls. What do we collect? IO-Tracer gathers system metrics strictly related to hardware performance. We analyze the mechanism of data requests without ever inspecting the data contents. By monitoring the interaction between computer layers, IO-Tracer captures the system-specific dialogue between components while ensuring user data remains private. How do we use the collected information? The information collected by IO-Tracer serves as valuable input for academic research. The collected data will be used to understand how hardware is used and helps us to design better software and hardware . Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent . We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"Introduction"},{"location":"#welcome-to-documentation-page-for-io-tracer","text":"Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology. Source code: https://github.com/cacheMon/io-tracer-win https://github.com/cacheMon/io-tracer","title":"Welcome to Documentation Page for IO-Tracer!"},{"location":"#what-is-io-tracer","text":"IO-Tracer is a research tool that collects information about how hardware is utilized. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices.","title":"What is IO-Tracer?"},{"location":"#background","text":"Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls.","title":"Background"},{"location":"#what-do-we-collect","text":"IO-Tracer gathers system metrics strictly related to hardware performance. We analyze the mechanism of data requests without ever inspecting the data contents. By monitoring the interaction between computer layers, IO-Tracer captures the system-specific dialogue between components while ensuring user data remains private.","title":"What do we collect?"},{"location":"#how-do-we-use-the-collected-information","text":"The information collected by IO-Tracer serves as valuable input for academic research. The collected data will be used to understand how hardware is used and helps us to design better software and hardware . Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent . We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"How do we use the collected information?"},{"location":"fields/","text":"Fields Collected Filesystem Request: Field Data Type Description Platform timestamp datetime The exact time when the request occurred Linux & Windows op_name string Operation type of the reqeust Linux & Windows pid int Process ID that performed the requst Linux & Windows process_name string Name of the process performing the request Linux & Windows filename string The full path or name of the file being access Linux & Windows inode int The inode number associated with the file Linux size int Data transfer amount in bytes Linux & Windows flags_str string String representation of file operation flags Linux State: Field Data Type Description Platform path string Full path of the file being recorded This will be anonimized if enabled Linux & Windows file_size int Size of the file in bytes Linux & Windows created_time float Timestamp when the file was created Linux & Windows modified_time float Timestamp when the file was last modified Linux & Windows Block Request: Field Data Type Description Platform timestamp datetime The time when the block I/O operation occurred Linux & Windows pid int Process ID that issued the I/O request Linux & Windows tid int Thread ID within the process that performed the I/O operation Linux process_name string Name of the process performing the block I/O Linux & Windows lba int Identifies the location of the I/O on disk Linux & Windows op_type string Operation type Linux & Windows size int Size of the I/O request in bytes Linux & Windows nr_sectors int Number of 512-byte sectors affected by the operation Linux cpu_id int CPU core ID where the I/O request was executed Linux parent_process_id int Process ID of the parent process that triggered the I/O Linux latency float Time it takes for a block request to finish Linux & Windows Cache Request: Field Data Type Description Platform timestamp int The time when the block I/O operation occurred Linux pid int Process identifier Linux process_name string Process command name Linux status string HIT or MISS Linux Network Field Data Type Description Platform timestamp datetime Time when the request was taken Linux & Windows pid int Process ID Linux & Windows process_name int Name of process that trigger the network request Linux & Windows source_address string Address source of the requests Linux & Windows destination_address string Address destination of the requests Linux & Windows source_port int Port source of the requests Linux & Windows destination_port int Port destination of the requests Linux & Windows size int Size of the request in bytes Linux & Windows type string The type of the request (send / receive) Linux & Windows Process State: Column Name Data Type Description Platform Availability timestamp datetime Time when the process state snapshot was taken Windows pid int Process ID Linux & Windows name string Process name Linux & Windows cmd string Full command line used to start the process Linux & Windows virtual_size int Virtual memory size of the process in bytes Windows only working_set_size int Amount of physical memory (RAM) currently used by the process, in bytes Windows only memory_info int Resident Set Size (RSS), actual physical memory used by the process Linux only creation_date datetime Time when the process was created Linux & Windows status string Current process state Linux cpu_usage_5s float CPU utilization percentage for the process, calculated in 5 second interval Linux & Windows cpu_usage_2m float CPU utilization percentage for the process, calculated in 2 minute interval Linux & Windows cpu_usage_1h float CPU utilization percentage for the process, calculated in 1 hour interval Linux & Windows","title":"Fields Collected"},{"location":"fields/#fields-collected","text":"","title":"Fields Collected"},{"location":"fields/#filesystem","text":"Request: Field Data Type Description Platform timestamp datetime The exact time when the request occurred Linux & Windows op_name string Operation type of the reqeust Linux & Windows pid int Process ID that performed the requst Linux & Windows process_name string Name of the process performing the request Linux & Windows filename string The full path or name of the file being access Linux & Windows inode int The inode number associated with the file Linux size int Data transfer amount in bytes Linux & Windows flags_str string String representation of file operation flags Linux State: Field Data Type Description Platform path string Full path of the file being recorded This will be anonimized if enabled Linux & Windows file_size int Size of the file in bytes Linux & Windows created_time float Timestamp when the file was created Linux & Windows modified_time float Timestamp when the file was last modified Linux & Windows","title":"Filesystem"},{"location":"fields/#block","text":"Request: Field Data Type Description Platform timestamp datetime The time when the block I/O operation occurred Linux & Windows pid int Process ID that issued the I/O request Linux & Windows tid int Thread ID within the process that performed the I/O operation Linux process_name string Name of the process performing the block I/O Linux & Windows lba int Identifies the location of the I/O on disk Linux & Windows op_type string Operation type Linux & Windows size int Size of the I/O request in bytes Linux & Windows nr_sectors int Number of 512-byte sectors affected by the operation Linux cpu_id int CPU core ID where the I/O request was executed Linux parent_process_id int Process ID of the parent process that triggered the I/O Linux latency float Time it takes for a block request to finish Linux & Windows","title":"Block"},{"location":"fields/#cache","text":"Request: Field Data Type Description Platform timestamp int The time when the block I/O operation occurred Linux pid int Process identifier Linux process_name string Process command name Linux status string HIT or MISS Linux","title":"Cache"},{"location":"fields/#network","text":"Field Data Type Description Platform timestamp datetime Time when the request was taken Linux & Windows pid int Process ID Linux & Windows process_name int Name of process that trigger the network request Linux & Windows source_address string Address source of the requests Linux & Windows destination_address string Address destination of the requests Linux & Windows source_port int Port source of the requests Linux & Windows destination_port int Port destination of the requests Linux & Windows size int Size of the request in bytes Linux & Windows type string The type of the request (send / receive) Linux & Windows","title":"Network"},{"location":"fields/#process","text":"State: Column Name Data Type Description Platform Availability timestamp datetime Time when the process state snapshot was taken Windows pid int Process ID Linux & Windows name string Process name Linux & Windows cmd string Full command line used to start the process Linux & Windows virtual_size int Virtual memory size of the process in bytes Windows only working_set_size int Amount of physical memory (RAM) currently used by the process, in bytes Windows only memory_info int Resident Set Size (RSS), actual physical memory used by the process Linux only creation_date datetime Time when the process was created Linux & Windows status string Current process state Linux cpu_usage_5s float CPU utilization percentage for the process, calculated in 5 second interval Linux & Windows cpu_usage_2m float CPU utilization percentage for the process, calculated in 2 minute interval Linux & Windows cpu_usage_1h float CPU utilization percentage for the process, calculated in 1 hour interval Linux & Windows","title":"Process"},{"location":"privacy/","text":"Privacy Protection Measures Anonymization Efforts IO Tracer provides an option for users to anonymize their data. This means that certain fields are anonymized through hashing. Fields that may contain sensitive information, such as filename / filepath and command , are locally hashed using the SHA-256 algorithm, making it impossible for us to view their original content. Filepath For file paths , our hashing method preserves the directory structure while anonymizing specific segments. Specifically, we hash the directory and file names beyond the first two levels, while keeping the top-level directories and the file extension intact. However, if there is only one level traced in the file path, the program will hash the whole structure. For example: /usr/bin/baz.txt \u2192 /usr/bin/baa5a0964d3320fb.txt /note.txt \u2192 /baa5a0964d3320fb.txt In contrast, command strings are fully hashed to ensure complete privacy. For instance: \"C:\\WINDOWS\\system32\\svchost.exe -k RPCSS -p\" \u2192 314b08c9fe3a404f Network In terms of network collection , we'll hash the ip sent and received that has been traced. Such as, 127.0.0.1 \u2192 4c232a5821 ::1 \u2192 7c102d5320 Excluded Information File contents or personal user data Network packet payloads User credentials or passwords Environment variables","title":"Privacy Protection Measures"},{"location":"privacy/#privacy-protection-measures","text":"","title":"Privacy Protection Measures"},{"location":"privacy/#anonymization-efforts","text":"IO Tracer provides an option for users to anonymize their data. This means that certain fields are anonymized through hashing. Fields that may contain sensitive information, such as filename / filepath and command , are locally hashed using the SHA-256 algorithm, making it impossible for us to view their original content.","title":"Anonymization Efforts"},{"location":"privacy/#filepath","text":"For file paths , our hashing method preserves the directory structure while anonymizing specific segments. Specifically, we hash the directory and file names beyond the first two levels, while keeping the top-level directories and the file extension intact. However, if there is only one level traced in the file path, the program will hash the whole structure. For example: /usr/bin/baz.txt \u2192 /usr/bin/baa5a0964d3320fb.txt /note.txt \u2192 /baa5a0964d3320fb.txt In contrast, command strings are fully hashed to ensure complete privacy. For instance: \"C:\\WINDOWS\\system32\\svchost.exe -k RPCSS -p\" \u2192 314b08c9fe3a404f","title":"Filepath"},{"location":"privacy/#network","text":"In terms of network collection , we'll hash the ip sent and received that has been traced. Such as, 127.0.0.1 \u2192 4c232a5821 ::1 \u2192 7c102d5320","title":"Network"},{"location":"privacy/#excluded-information","text":"File contents or personal user data Network packet payloads User credentials or passwords Environment variables","title":"Excluded Information"},{"location":"startlinux/","text":"Quick Start Guide | Linux Prerequisites Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC Clone the IO Tracer repository git clone https://github.com/cacheMon/io-tracer.git Instal BCC: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide Finally, install these last two libraries! # ubuntu sudo apt install python3-psutil sudo apt install python3-requests # ... (adjust the package manager for other distros) You are all set. Basic Usages Start tracing sudo python3 iotrc.py Tracing with anonymization sudo python3 iotrc.py -a Command Options usage: iotrc.py [-h] [-o OUTPUT] [-v VERBOSE] [-a] [-l] [--dev] Trace IO syscalls options: -h, --help show this help message and exit -o OUTPUT, --output OUTPUT Output Directory for logging -v VERBOSE, --verbose VERBOSE Print verbose output -a, --anonimize Enable anonymization of process and file names -l, --local-only Disable automatic upload of logs, save the trace locally --dev Developer mode with extra logs and checks","title":"Quick Start Linux"},{"location":"startlinux/#quick-start-guide-linux","text":"","title":"Quick Start Guide | Linux"},{"location":"startlinux/#prerequisites","text":"Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC Clone the IO Tracer repository git clone https://github.com/cacheMon/io-tracer.git Instal BCC: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide Finally, install these last two libraries! # ubuntu sudo apt install python3-psutil sudo apt install python3-requests # ... (adjust the package manager for other distros) You are all set.","title":"Prerequisites"},{"location":"startlinux/#basic-usages","text":"Start tracing sudo python3 iotrc.py Tracing with anonymization sudo python3 iotrc.py -a","title":"Basic Usages"},{"location":"startlinux/#command-options","text":"usage: iotrc.py [-h] [-o OUTPUT] [-v VERBOSE] [-a] [-l] [--dev] Trace IO syscalls options: -h, --help show this help message and exit -o OUTPUT, --output OUTPUT Output Directory for logging -v VERBOSE, --verbose VERBOSE Print verbose output -a, --anonimize Enable anonymization of process and file names -l, --local-only Disable automatic upload of logs, save the trace locally --dev Developer mode with extra logs and checks","title":"Command Options"},{"location":"startwin/","text":"Quick Start Guide | Windows Installation \ud83c\udfa5 Here\u2019s a quick video guide on Tracer installation Download winiotracer.zip from here and extract it. Find IOTracesCORE.exe , then open it. \u26a0\ufe0f IMPORTANT : It's possible that your system flagged our tool as suspicious software. Bypass it by choosing \"keep anyway\" option whenever possible. This is because the app is not signed with a developer certificate. Installation complete! Basic Usage Run the program as administrator Right\u2013click the application with the binocular icon and choose Run as administrator . Program starts running Once started, you\u2019ll be prompted to several options. Options Description Anonymous if you want to hide some potentially sensitive data . Enable Automatic Upload if you want the trace to automatically upload to our infrastructure. Start on startup if you want the program to automatically run every boot If you're comfortable with your choice, hit the run button. The program is currently active running in the background. You can check its status by right clicking tray icon. Exiting the program Click the exit button from the tray icon A dialog will pop up telling you to wait while the program doing some cleaning up Once the dialog closed, the program has gracefully closed. Check the output If you close the program properly, results will be saved inside the output path you have set! \u26a0\ufe0f Important: We recommend exiting the program before shutting down to ensure all data is saved correctly.","title":"Quick Start Windows"},{"location":"startwin/#quick-start-guide-windows","text":"","title":"Quick Start Guide | Windows"},{"location":"startwin/#installation","text":"\ud83c\udfa5 Here\u2019s a quick video guide on Tracer installation Download winiotracer.zip from here and extract it. Find IOTracesCORE.exe , then open it. \u26a0\ufe0f IMPORTANT : It's possible that your system flagged our tool as suspicious software. Bypass it by choosing \"keep anyway\" option whenever possible. This is because the app is not signed with a developer certificate. Installation complete!","title":"Installation"},{"location":"startwin/#basic-usage","text":"","title":"Basic Usage"},{"location":"startwin/#run-the-program-as-administrator","text":"Right\u2013click the application with the binocular icon and choose Run as administrator .","title":"Run the program as administrator"},{"location":"startwin/#program-starts-running","text":"Once started, you\u2019ll be prompted to several options. Options Description Anonymous if you want to hide some potentially sensitive data . Enable Automatic Upload if you want the trace to automatically upload to our infrastructure. Start on startup if you want the program to automatically run every boot If you're comfortable with your choice, hit the run button. The program is currently active running in the background. You can check its status by right clicking tray icon.","title":"Program starts running"},{"location":"startwin/#exiting-the-program","text":"Click the exit button from the tray icon A dialog will pop up telling you to wait while the program doing some cleaning up Once the dialog closed, the program has gracefully closed.","title":"Exiting the program"},{"location":"startwin/#check-the-output","text":"If you close the program properly, results will be saved inside the output path you have set! \u26a0\ufe0f Important: We recommend exiting the program before shutting down to ensure all data is saved correctly.","title":"Check the output"},{"location":"technicalnux/","text":"Technical Details - Linux We are implementing eBPF through BPF Compiler Collection . Kernel probes are then attached to several system calls that are related to I/O activities. These system calls are in a group of Linux Storage Stack . Systems call that we used are as such: Layer Syscall Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer block_rq_issue , block_rq_complete Page filemap_add_folio , folio_mark_accessed","title":"Technical Details Linux"},{"location":"technicalnux/#technical-details-linux","text":"We are implementing eBPF through BPF Compiler Collection . Kernel probes are then attached to several system calls that are related to I/O activities. These system calls are in a group of Linux Storage Stack . Systems call that we used are as such: Layer Syscall Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer block_rq_issue , block_rq_complete Page filemap_add_folio , folio_mark_accessed","title":"Technical Details - Linux"},{"location":"technicalwin/","text":"Technical Details - Windows Event Tracing for Windows (ETW) Libraries Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time Implementation Details Session Management The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators. Event Processing Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite.","title":"Technical Details Windows"},{"location":"technicalwin/#technical-details-windows","text":"","title":"Technical Details - Windows"},{"location":"technicalwin/#event-tracing-for-windows-etw-libraries","text":"Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time","title":"Event Tracing for Windows (ETW) Libraries"},{"location":"technicalwin/#implementation-details","text":"","title":"Implementation Details"},{"location":"technicalwin/#session-management","text":"The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators.","title":"Session Management"},{"location":"technicalwin/#event-processing","text":"Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite.","title":"Event Processing"},{"location":"uploadguide/","text":"Upload Guide This page contains the information about manual traces uploads procedure . If you're using automatic upload, you can skip this. Trace Output Format Each time you stop the tracer, the tool saves a set of files. The files are stored in a folder with this pattern: Windows: [output path chosen]\\windows_trace\\[pc_identifier]\\[initial run timestamp]\\[trace_output_type]\\[trace_file].csv.zst Linux: [output path chosen]/linux_trace/[pc_identifier]/[initial run timestamp]/[trace_output_type]/[trace_file].csv.gz What to upload? Open the output path that you have set on your tracer. In my case, I saved it to Documents\\WorkloadTrace Please upload the whole windows_trace or linux_trace folder. DO NOT remove anything inside it. Where to upload? Upload the folder here: https://www.dropbox.com/request/cOJOGlm57Xn70pSC4ltg You're done!","title":"Upload Guide"},{"location":"uploadguide/#upload-guide","text":"This page contains the information about manual traces uploads procedure . If you're using automatic upload, you can skip this.","title":"Upload Guide"},{"location":"uploadguide/#trace-output-format","text":"Each time you stop the tracer, the tool saves a set of files. The files are stored in a folder with this pattern: Windows: [output path chosen]\\windows_trace\\[pc_identifier]\\[initial run timestamp]\\[trace_output_type]\\[trace_file].csv.zst Linux: [output path chosen]/linux_trace/[pc_identifier]/[initial run timestamp]/[trace_output_type]/[trace_file].csv.gz","title":"Trace Output Format"},{"location":"uploadguide/#what-to-upload","text":"Open the output path that you have set on your tracer. In my case, I saved it to Documents\\WorkloadTrace Please upload the whole windows_trace or linux_trace folder. DO NOT remove anything inside it.","title":"What to upload?"},{"location":"uploadguide/#where-to-upload","text":"Upload the folder here: https://www.dropbox.com/request/cOJOGlm57Xn70pSC4ltg You're done!","title":"Where to upload?"}]}