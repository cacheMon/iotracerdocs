{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Documentation Page for IO-Tracer! Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology. What is IO-Tracer? IO-Tracer is a research tool that collects information about how computers use their storage systems. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices. Background Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls. What do we collect? IO-Tracer collects five key types of hardware information to provide comprehensive insights into computational operations. First, it captures the precise timestamp of each operation to establish when activities occur. Second, it records the type of operation being performed, whether it's opening, reading, writing, or closing files. Third, it identifies which specific process ( process name ) is performing each operation. Finally, it logs the file location information, including both the file path and technical identifiers that specify where operations are taking place. Finally, it measures the size of data being requested during each operation. How do we use the collected information? The information collected by IO-Tracer serves as valuable input for academic research. Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent. We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"Introduction"},{"location":"#welcome-to-documentation-page-for-io-tracer","text":"Technical documentation for Linux and Windows kernel-level I/O tracing system using eBPF and ETW technology.","title":"Welcome to Documentation Page for IO-Tracer!"},{"location":"#what-is-io-tracer","text":"IO-Tracer is a research tool that collects information about how computers use their storage systems. Researchers use this tool to understand real-world computer workloads, essentially studying patterns of how different processes and users interact with files and storage devices.","title":"What is IO-Tracer?"},{"location":"#background","text":"Most operations occurring within our computers remain invisible to users. This design choice makes sense because the average user doesn't need detailed information about every process running under the hood. However, researchers have a different perspective. They're deeply interested in understanding and visualizing the intricate pathways of computational operations that power our digital experiences. To understand these computational pathways, we need a specialized program capable of monitoring them. This is where IO-Tracer comes in. IO-Tracer operates as an intermediary layer between your daily applications and your computer's hardware, residing within the operating system without disrupting existing operations. This tool captures all the necessary hardware information for research purposes while maintaining strict privacy standards. It cannot access the content within your files and only collects metadata such as file names and system calls.","title":"Background"},{"location":"#what-do-we-collect","text":"IO-Tracer collects five key types of hardware information to provide comprehensive insights into computational operations. First, it captures the precise timestamp of each operation to establish when activities occur. Second, it records the type of operation being performed, whether it's opening, reading, writing, or closing files. Third, it identifies which specific process ( process name ) is performing each operation. Finally, it logs the file location information, including both the file path and technical identifiers that specify where operations are taking place. Finally, it measures the size of data being requested during each operation.","title":"What do we collect?"},{"location":"#how-do-we-use-the-collected-information","text":"The information collected by IO-Tracer serves as valuable input for academic research. Individual datasets are aggregated with data from other participants to reveal meaningful patterns and generate statistical insights about computational behavior. Access to this research information is strictly limited to authorized researchers. Throughout the collection process, all information remains securely stored on the user's personal computer, ensuring complete user control over their data. The research team can only access the hardware information through direct user consent. We must explicitly request permission from each participant before any information is transferred from their system to our research infrastructure.","title":"How do we use the collected information?"},{"location":"fields/","text":"Fields Collected Filesystem Request: Field Data Type Description Platform timestamp datetime The exact time when the request occurred. Linux & Windows op_name string Operation type of the reqeust Linux & Windows pid int Process ID that performed the requst. Linux & Windows process_name string Name of the process performing the request. Linux & Windows filename string The full path or name of the file being access. Linux & Windows inode int The inode number associated with the file. Linux size_val_bytes int Data transfer amount in bytes. Linux & Windows flags_str string String representation of file operation flags. Linux State: Field Data Type Description Platform path string Full path of the file being recorded. This will be anonimized if enabled. Linux & Windows file_size int Size of the file in bytes. Linux & Windows created_time float Timestamp when the file was created. Linux & Windows modified_time float Timestamp when the file was last modified. Linux & Windows Block Request: Field Data Type Description Platform timestamp datetime The time when the block I/O operation occurred. Linux & Windows pid int Process ID that issued the I/O request. Linux & Windows tid int Thread ID within the process that performed the I/O operation. Linux process_name string Name of the process performing the block I/O. Linux & Windows lba int Identifies the location of the I/O on disk. Linux & Windows op_type string Operation type. Linux & Windows size int Size of the I/O request in bytes. Linux & Windows nr_sectors int Number of 512-byte sectors affected by the operation. Linux cpu_id int CPU core ID where the I/O request was executed. Linux parent_process_id int Process ID of the parent process that triggered the I/O. Linux parent_process string Name of the parent process that triggered the I/O. Linux Cache Request: Field Data Type Description Platform timestamp int The time when the block I/O operation occurred. Linux pid int Process identifier Linux comm string Process command name Linux status string HIT or MISS Linux Process State: Column Name Data Type Description Platform Availability timestamp datetime Time when the process state snapshot was taken. Windows pid int Process ID. Linux & Windows name string Process name. Linux & Windows cmd string Full command line used to start the process. Linux & Windows virtual_size int Virtual memory size of the process in bytes. Windows only working_set_size int Amount of physical memory (RAM) currently used by the process, in bytes. Windows only memory_info int Resident Set Size (RSS), actual physical memory used by the process. Linux only creation_date datetime Time when the process was created. Linux & Windows status string Current process state. Linux cpu_usage float CPU utilization percentage for the process. Linux & Windows","title":"Fields Collected"},{"location":"fields/#fields-collected","text":"","title":"Fields Collected"},{"location":"fields/#filesystem","text":"Request: Field Data Type Description Platform timestamp datetime The exact time when the request occurred. Linux & Windows op_name string Operation type of the reqeust Linux & Windows pid int Process ID that performed the requst. Linux & Windows process_name string Name of the process performing the request. Linux & Windows filename string The full path or name of the file being access. Linux & Windows inode int The inode number associated with the file. Linux size_val_bytes int Data transfer amount in bytes. Linux & Windows flags_str string String representation of file operation flags. Linux State: Field Data Type Description Platform path string Full path of the file being recorded. This will be anonimized if enabled. Linux & Windows file_size int Size of the file in bytes. Linux & Windows created_time float Timestamp when the file was created. Linux & Windows modified_time float Timestamp when the file was last modified. Linux & Windows","title":"Filesystem"},{"location":"fields/#block","text":"Request: Field Data Type Description Platform timestamp datetime The time when the block I/O operation occurred. Linux & Windows pid int Process ID that issued the I/O request. Linux & Windows tid int Thread ID within the process that performed the I/O operation. Linux process_name string Name of the process performing the block I/O. Linux & Windows lba int Identifies the location of the I/O on disk. Linux & Windows op_type string Operation type. Linux & Windows size int Size of the I/O request in bytes. Linux & Windows nr_sectors int Number of 512-byte sectors affected by the operation. Linux cpu_id int CPU core ID where the I/O request was executed. Linux parent_process_id int Process ID of the parent process that triggered the I/O. Linux parent_process string Name of the parent process that triggered the I/O. Linux","title":"Block"},{"location":"fields/#cache","text":"Request: Field Data Type Description Platform timestamp int The time when the block I/O operation occurred. Linux pid int Process identifier Linux comm string Process command name Linux status string HIT or MISS Linux","title":"Cache"},{"location":"fields/#process","text":"State: Column Name Data Type Description Platform Availability timestamp datetime Time when the process state snapshot was taken. Windows pid int Process ID. Linux & Windows name string Process name. Linux & Windows cmd string Full command line used to start the process. Linux & Windows virtual_size int Virtual memory size of the process in bytes. Windows only working_set_size int Amount of physical memory (RAM) currently used by the process, in bytes. Windows only memory_info int Resident Set Size (RSS), actual physical memory used by the process. Linux only creation_date datetime Time when the process was created. Linux & Windows status string Current process state. Linux cpu_usage float CPU utilization percentage for the process. Linux & Windows","title":"Process"},{"location":"privacy/","text":"Privacy Protection Measures Anonymization Efforts IO Tracer provides an option for users to anonymize their data. This means that certain fields are anonymized through hashing. Fields that may contain sensitive information, such as filename / filepath and command , are locally hashed using the SHA-256 algorithm, making it impossible for us to view their original content. For file paths, our hashing method preserves the directory structure while anonymizing specific segments. Specifically, we hash the directory and file names beyond the first two levels, while keeping the top-level directories and the file extension intact. For example: foo/bar/baz.txt \u2192 foo/bar/baa5a0964d3320fb.txt In contrast, command strings are fully hashed to ensure complete privacy. For instance: \"C:\\WINDOWS\\system32\\svchost.exe -k RPCSS -p\" \u2192 314b08c9fe3a404f Automatic Filtering The tool systematically excludes virtual filesystems such as /proc , /sys , /dev , and tmpfs , which contain system-generated information rather than hardware information. To prevent recursive loops and maintain system performance, the tracer implements self-tracing prevention by automatically excluding its own input/output operations from the collection. Additionally, the system filters out special files including pipes, sockets, and device files. Data Minimization Techniques The tool features configurable cache event sampling, allowing researchers to capture representative information patterns by recording only a specified ratio of events, such as one in every ten operations. To prevent excessive storage consumption, the tool implements time-based log rotation with a default 24-hour cycle, automatically archiving older data while maintaining recent activity logs. Process-specific filtering capabilities enable users to focus data collection on particular applications or exclude unnecessary system processes from monitoring. Finally, the tool incorporates automatic compression and cleanup routines that optimize storage space and remove outdated information. Excluded Information File contents or personal user data Network packet payloads User credentials or passwords Environment variables","title":"Privacy Protection Measures"},{"location":"privacy/#privacy-protection-measures","text":"","title":"Privacy Protection Measures"},{"location":"privacy/#anonymization-efforts","text":"IO Tracer provides an option for users to anonymize their data. This means that certain fields are anonymized through hashing. Fields that may contain sensitive information, such as filename / filepath and command , are locally hashed using the SHA-256 algorithm, making it impossible for us to view their original content. For file paths, our hashing method preserves the directory structure while anonymizing specific segments. Specifically, we hash the directory and file names beyond the first two levels, while keeping the top-level directories and the file extension intact. For example: foo/bar/baz.txt \u2192 foo/bar/baa5a0964d3320fb.txt In contrast, command strings are fully hashed to ensure complete privacy. For instance: \"C:\\WINDOWS\\system32\\svchost.exe -k RPCSS -p\" \u2192 314b08c9fe3a404f","title":"Anonymization Efforts"},{"location":"privacy/#automatic-filtering","text":"The tool systematically excludes virtual filesystems such as /proc , /sys , /dev , and tmpfs , which contain system-generated information rather than hardware information. To prevent recursive loops and maintain system performance, the tracer implements self-tracing prevention by automatically excluding its own input/output operations from the collection. Additionally, the system filters out special files including pipes, sockets, and device files.","title":"Automatic Filtering"},{"location":"privacy/#data-minimization-techniques","text":"The tool features configurable cache event sampling, allowing researchers to capture representative information patterns by recording only a specified ratio of events, such as one in every ten operations. To prevent excessive storage consumption, the tool implements time-based log rotation with a default 24-hour cycle, automatically archiving older data while maintaining recent activity logs. Process-specific filtering capabilities enable users to focus data collection on particular applications or exclude unnecessary system processes from monitoring. Finally, the tool incorporates automatic compression and cleanup routines that optimize storage space and remove outdated information.","title":"Data Minimization Techniques"},{"location":"privacy/#excluded-information","text":"File contents or personal user data Network packet payloads User credentials or passwords Environment variables","title":"Excluded Information"},{"location":"startlinux/","text":"Quick Start Guide | Linux Prerequisites Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC You can execute these commands for BCC installation: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide Basic Usages Infinite tracing (Exit on demand) sudo python3 iotrc.py Quick Start (30 Seconds Trace) sudo python3 iotrc.py -d 30 Command Options Core options -d, --duration <seconds> - Duration to trace (default: indefinite) -o, --output <directory> - Output directory (default: auto-generated) -v, --verbose - Enable verbose logging -a, --anonimize - Anonymize process and file names Advance options -b BPF_FILE, --bpf-file BPF_FILE - BPF C source file path -p PAGE_CNT, --page-cnt PAGE_CNT - Number of pages for perf buffer (default 8) -s SPLIT_THRESHOLD, --split_threshold SPLIT_THRESHOLD - Split threshold in seconds (default 1 day) -a, --anonimize - Enable anonymization of process and file names -uc, --uncompressed - Enable uncompressed output","title":"Quick Start Linux"},{"location":"startlinux/#quick-start-guide-linux","text":"","title":"Quick Start Guide | Linux"},{"location":"startlinux/#prerequisites","text":"Linux system with kernel headers Python 3.x sudo privileges (required for BPF operations) BPF Compiler Collection / BCC You can execute these commands for BCC installation: # Debian echo deb http://cloudfront.debian.net/debian sid main >> /etc/apt/sources.list sudo apt-get install -y bpfcc-tools libbpfcc libbpfcc-dev linux-headers-$(uname -r) # Ubuntu sudo apt-get install bpfcc-tools linux-headers-$(uname -r) # Fedora sudo dnf install bcc # Arch pacman -S bcc bcc-tools python-bcc For more distros, visit the official BCC's installation guide","title":"Prerequisites"},{"location":"startlinux/#basic-usages","text":"Infinite tracing (Exit on demand) sudo python3 iotrc.py Quick Start (30 Seconds Trace) sudo python3 iotrc.py -d 30","title":"Basic Usages"},{"location":"startlinux/#command-options","text":"","title":"Command Options"},{"location":"startlinux/#core-options","text":"-d, --duration <seconds> - Duration to trace (default: indefinite) -o, --output <directory> - Output directory (default: auto-generated) -v, --verbose - Enable verbose logging -a, --anonimize - Anonymize process and file names","title":"Core options"},{"location":"startlinux/#advance-options","text":"-b BPF_FILE, --bpf-file BPF_FILE - BPF C source file path -p PAGE_CNT, --page-cnt PAGE_CNT - Number of pages for perf buffer (default 8) -s SPLIT_THRESHOLD, --split_threshold SPLIT_THRESHOLD - Split threshold in seconds (default 1 day) -a, --anonimize - Enable anonymization of process and file names -uc, --uncompressed - Enable uncompressed output","title":"Advance options"},{"location":"startwin/","text":"Quick Start Guide | Windows Installation In order to use the program, please install the .NET 8.0 first then the Tracer tool. \ud83c\udfa5 Here\u2019s a quick video guide on .NET 8.0 installation (P.S. Just follow it until the installation completed) Tracer installation .NET 8.0 Install .NET 8.0 framework from Microsoft's official download page. Verify your installation by running dotnet --info in the terminal Tracer Download the .zip / .tar file from the GitHub Release page and extract it. Move the extracted folder to your preferred location. We recommend placing it under the Documents folder for easy access. Installation complete! Basic Usage Run the program as administrator Right\u2013click the file with the binocular icon and choose Run as administrator . Program starts running Once started, you\u2019ll be prompted to several options. If you're comfortable with your choice, hit the run button. The program is currently active running in the background. You can check its status by right clicking tray icon. Exiting the program Click the exit button from the tray icon A dialog will pop up telling you to wait while the program doing some cleaning up Once the dialog closed, the program has gracefully closed. Check the output If you close the program properly, results will be saved inside the output path you have set! \u26a0\ufe0f Important: It's better for us to close the program if you want to shut your device. We'd like to prevent corruption happening during the data collection process \ud83d\ude09.","title":"Quick Start Windows"},{"location":"startwin/#quick-start-guide-windows","text":"","title":"Quick Start Guide | Windows"},{"location":"startwin/#installation","text":"In order to use the program, please install the .NET 8.0 first then the Tracer tool. \ud83c\udfa5 Here\u2019s a quick video guide on .NET 8.0 installation (P.S. Just follow it until the installation completed) Tracer installation","title":"Installation"},{"location":"startwin/#net-80","text":"Install .NET 8.0 framework from Microsoft's official download page. Verify your installation by running dotnet --info in the terminal","title":".NET 8.0"},{"location":"startwin/#tracer","text":"Download the .zip / .tar file from the GitHub Release page and extract it. Move the extracted folder to your preferred location. We recommend placing it under the Documents folder for easy access. Installation complete!","title":"Tracer"},{"location":"startwin/#basic-usage","text":"","title":"Basic Usage"},{"location":"startwin/#run-the-program-as-administrator","text":"Right\u2013click the file with the binocular icon and choose Run as administrator .","title":"Run the program as administrator"},{"location":"startwin/#program-starts-running","text":"Once started, you\u2019ll be prompted to several options. If you're comfortable with your choice, hit the run button. The program is currently active running in the background. You can check its status by right clicking tray icon.","title":"Program starts running"},{"location":"startwin/#exiting-the-program","text":"Click the exit button from the tray icon A dialog will pop up telling you to wait while the program doing some cleaning up Once the dialog closed, the program has gracefully closed.","title":"Exiting the program"},{"location":"startwin/#check-the-output","text":"If you close the program properly, results will be saved inside the output path you have set! \u26a0\ufe0f Important: It's better for us to close the program if you want to shut your device. We'd like to prevent corruption happening during the data collection process \ud83d\ude09.","title":"Check the output"},{"location":"technicalnux/","text":"Technical Details - Linux Data Collection Methodology Implementation Using eBPF-based kernel probes (kprobes) Kernel Probe Points Layer Functions Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer blk_mq_start_request Page Cache filemap_add_folio (miss), folio_mark_accessed (hit) Output Directory Structures result/IO_trace_analysis_YYYYMMDD_HHMMSS/ \u251c\u2500 raw_trace_YYYYMMDD_HHMMSS.tar.gz \u251c\u2500\u2500 vfs/log/vfs_trace_*.log \u251c\u2500\u2500 block/log/block_trace_*.log \u2514\u2500\u2500 cache/log/cache_trace_*.log Filesystem Trace Format Log Format timestamp op_name pid comm filename inode size_val flags_str Field Specs Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive op_name string Operation (READ/WRITE/OPEN/CLOSE/FSYNC) Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) filename char[256] File name Non-sensitive (Does not contain personal info) inode uint64 File inode number Non-sensitive size_val uint64 I/O size in bytes Non-sensitive flags_str string Open flags (e.g., O_RDONLY) Non-sensitive Example: 1234567890 READ 1234 firefox config.txt 98765 4096 O_RDONLY|O_DIRECT Block I/O Trace Format Log Format timestamp pid tid comm sector nr_sectors operation cpu_id parent_info bio_size Field Spec Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive tid uint32 Thread identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) sector uint64 Disk sector (LBA) Non-sensitive nr_sectors uint32 Number of sectors Non-sensitive operation string Operation type (REQ_OP_READ/WRITE) Non-sensitive cpu_id uint32 CPU core identifier Non-sensitive parent_info string Parent process information Non-sensitive (Does not contain personal info) bio_size uint64 Block I/O size in bytes Non-sensitive Example: 1234567890 1234 5678 mysqld 2048576 256 REQ_OP_WRITE cpu:0 ppid:1(systemd) 131072 Page Cache Trace Data Format Log Format timestamp pid comm status Field Spec Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive status string HIT or MISS Non-sensitive Example: 1234567890 1234 chrome HIT","title":"Technical Details Linux"},{"location":"technicalnux/#technical-details-linux","text":"","title":"Technical Details - Linux"},{"location":"technicalnux/#data-collection-methodology","text":"","title":"Data Collection Methodology"},{"location":"technicalnux/#implementation","text":"Using eBPF-based kernel probes (kprobes)","title":"Implementation"},{"location":"technicalnux/#kernel-probe-points","text":"Layer Functions Traced VFS Layer vfs_read , vfs_write , vfs_open , vfs_fsync , vfs_fsync_range , __fput Block Layer blk_mq_start_request Page Cache filemap_add_folio (miss), folio_mark_accessed (hit)","title":"Kernel Probe Points"},{"location":"technicalnux/#output-directory-structures","text":"result/IO_trace_analysis_YYYYMMDD_HHMMSS/ \u251c\u2500 raw_trace_YYYYMMDD_HHMMSS.tar.gz \u251c\u2500\u2500 vfs/log/vfs_trace_*.log \u251c\u2500\u2500 block/log/block_trace_*.log \u2514\u2500\u2500 cache/log/cache_trace_*.log","title":"Output Directory Structures"},{"location":"technicalnux/#filesystem-trace-format","text":"","title":"Filesystem Trace Format"},{"location":"technicalnux/#log-format","text":"timestamp op_name pid comm filename inode size_val flags_str","title":"Log Format"},{"location":"technicalnux/#field-specs","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive op_name string Operation (READ/WRITE/OPEN/CLOSE/FSYNC) Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) filename char[256] File name Non-sensitive (Does not contain personal info) inode uint64 File inode number Non-sensitive size_val uint64 I/O size in bytes Non-sensitive flags_str string Open flags (e.g., O_RDONLY) Non-sensitive Example: 1234567890 READ 1234 firefox config.txt 98765 4096 O_RDONLY|O_DIRECT","title":"Field Specs"},{"location":"technicalnux/#block-io-trace-format","text":"","title":"Block I/O Trace Format"},{"location":"technicalnux/#log-format_1","text":"timestamp pid tid comm sector nr_sectors operation cpu_id parent_info bio_size","title":"Log Format"},{"location":"technicalnux/#field-spec","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive tid uint32 Thread identifier Non-sensitive comm char[16] Process command name Non-sensitive (Does not contain personal info) sector uint64 Disk sector (LBA) Non-sensitive nr_sectors uint32 Number of sectors Non-sensitive operation string Operation type (REQ_OP_READ/WRITE) Non-sensitive cpu_id uint32 CPU core identifier Non-sensitive parent_info string Parent process information Non-sensitive (Does not contain personal info) bio_size uint64 Block I/O size in bytes Non-sensitive Example: 1234567890 1234 5678 mysqld 2048576 256 REQ_OP_WRITE cpu:0 ppid:1(systemd) 131072","title":"Field Spec"},{"location":"technicalnux/#page-cache-trace-data-format","text":"","title":"Page Cache Trace Data Format"},{"location":"technicalnux/#log-format_2","text":"timestamp pid comm status","title":"Log Format"},{"location":"technicalnux/#field-spec_1","text":"Field Data Type Description Privacy Level timestamp uint64 Nanoseconds since boot Non-sensitive pid uint32 Process identifier Non-sensitive comm char[16] Process command name Non-sensitive status string HIT or MISS Non-sensitive Example: 1234567890 1234 chrome HIT","title":"Field Spec"},{"location":"technicalwin/","text":"Technical Details - Windows Event Tracing for Windows (ETW) Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time Implementation Details Session Management The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators. Event Processing Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite. Event Types Captured File system operations include Read , Write , Create , Delete , Close , and Flush operations. Raw disk I/O operations are captured to monitor low-level disk read/write operations. Memory-related events such as page faults and virtual memory allocation are available but currently disabled in the implementation.","title":"Technical Details Windows"},{"location":"technicalwin/#technical-details-windows","text":"","title":"Technical Details - Windows"},{"location":"technicalwin/#event-tracing-for-windows-etw","text":"Microsoft.Diagnostics.Tracing Primary library for ETW interaction TraceEventSession Manages kernel-level tracing sessions KernelTraceEventParser Parses kernel events in real-time","title":"Event Tracing for Windows (ETW)"},{"location":"technicalwin/#implementation-details","text":"","title":"Implementation Details"},{"location":"technicalwin/#session-management","text":"The system creates a unique ETW session per process ID to avoid conflicts and ensure isolated tracing. It requires elevated privileges for kernel provider access, as kernel-level events can only be captured by administrators.","title":"Session Management"},{"location":"technicalwin/#event-processing","text":"Events are processed in real-time as they occur via the source.Process() methods. The architecture uses a handler-based approach with dedicated handlers for filesystem and disk operations. Kernel integration is achieved through direct subscription to specific kernel events such as FileIORead and DiskIOWrite.","title":"Event Processing"},{"location":"technicalwin/#event-types-captured","text":"File system operations include Read , Write , Create , Delete , Close , and Flush operations. Raw disk I/O operations are captured to monitor low-level disk read/write operations. Memory-related events such as page faults and virtual memory allocation are available but currently disabled in the implementation.","title":"Event Types Captured"}]}